{
  "hash": "d924561d03b3ff23908fdaba5e4ce54e",
  "result": {
    "engine": "knitr",
    "markdown": "---\npagetitle: \"SARS Genomic Surveillance\"\noutput: html_document\n---\n\n\n\n\n# R fundamentals {.unnumbered}\n\nThis section gives a (very) quick and brief introduction to R and RStudio. \nIt will not teach you the details of how to program in R, but it should serve as a basis to start you on that journey. \nR can be used for a range of data analysis applications, including statistics, machine learning, plotting, image analysis, bioinformatics, etc. \nR is also a programming language, which makes it very flexible. \nWith this flexibility, comes a somewhat steeper learning curve, compared to point-and-click programs. \nHowever, in the long run it can really help you improve as a data analyst. \n\nThese materials will not teach you the details of how to write your own R programs (we won't have time for these), but to make you familiar with some of its applications and how to use RStudio to run your code.\nIt's only the start of your journey into R programming. \n\nIf you want to learn more about this topic, we recommend:\n\n- [R for Data Science](https://r4ds.had.co.nz/) - available as a free e-book.\n- [Introduction to R/tidyverse](https://tavareshugo.github.io/r-intro-tidyverse-gapminder/) - course materials introducing R and the `tidyverse` packages. \n\n\n## RStudio\n\nR is the software and programming language itself, but the R interface is quite basic and not very user-friendly. \nFortunately, there is a companion piece of software called **_RStudio_**, which makes working with R a little bit easier. \n\nThere are 4 basic panels in RStudio (see image below):\n\n- The **script** panel is essentially a text editor, where we can write code and save it as a text file, which in this case, because it contains R code, we call it an R script (but remember, a script is just a text file with some code in it. We've been creating shell scripts that run on the command line, here we have some R scripts, which contain R code)\n- The **console** panel is where the code actually runs, or is executed. This is equivalent to the terminal, on the command line. If we want to execute a line of code, then we need to run it on the console. \n  - One nice feature of RStudio is that we can edit our code on the script panel and then run a line of code from the script on the console - it's like copy/pasting that line of code from the script to the console. This makes working interactively with RStudio much easier, because we can edit our code in the script and run it as we go along. \n- On the top-right we have the **Environment** panel, which shows us objects that we create, that store information such as tables of data that we read into R. \n- Finally, on the bottom-right there are a few tabs: a **file browser** (allowing us to see files in our computer), a **plot display** tab (for plots we generate) and a **help** tab to look at documentation.\n\n![](images/rstudio_panels.png)\n\n\n### Setting RStudio\n\nBefore we start working with RStudio, it's a good idea to change one of its default options. \nGo to <kbd>Tools</kbd> → <kbd>Global Options...</kbd> and change the following:\n\n![](images/rstudio_setup.png)\n\nThis will tell RStudio to NOT automatically save and load things that we have done in the past. \nYou may think this is a helpful thing, but actually it's very inconvenient, because if you are doing multiple analysis, it might get very very confusing what the objects that you created are! \nSo, it's always best to start R with a fresh session, and setting these options makes sure we do this. \n\n\n### Starting a Project\n\nR has a concept called **working directory**, which is the location on your computer where it is working from (looking for files and folders). \nYou can think of it as the folder that you `cd` into if you were working on the command-line. \n\nThe easiest way to ensure that R is using the correct working directory for our analysis, is to create an **R project**. \nIn RStudio: <kbd>File</kbd> → <kbd>New Project...</kbd> → <kbd>Existing Directory</kbd> and then click the <kbd>Browse...</kbd> button to navigate to the folder where your project files are located. \n\nThis will create an `.Rproj` file on your project folder. \nNext time you want to work on your analysis, you can simply double-click on this file, and it will open RStudio, with the correct working directory already set for you. \n\n\n## R Basics\n\nThis section introduces some of the basic concepts in the R programming language. \n\n### Packages/Libraries\n\nR has several extensions to the basic functionality called “packages” or “libraries”. \nA popular library for data manipulation is called `tidyverse`, which we are using in this course. \nEach time we start a new R session, we need to load the libraries we want to use: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nIf you get an error like `Error in library(tidyverse) : there is no package called 'tidyverse'`, that means that you didn't install the package. \nTo install packages you can run: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"tidyverse\")\n```\n:::\n\n\nYou only need to do this the first time you want to use a library. \nOnce it's installed, you don't need to run this command again (unless you want to update the library to its latest version -- often a good idea!).\n\n\n### Create objects\n\nCreate **objects** (something that contains a value) with `<-`.\nFor example, the following creates an object called `x` containing a single number:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 53.341\n```\n:::\n\n\nWe can print the content of the object by typing its name:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 53.341\n```\n\n\n:::\n:::\n\n\n\n### Functions\n\nMost of the tasks we can achieve in R are done through the use of **functions**. \nWe can think of functions as mini-programs that take an input and give an output.\n\nFunctions are easy to identify, because they are always followed by parenthesis. \nInside the parenthesis we include the _inputs_ to the function. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(x)   # round the the value of x\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 53\n```\n\n\n:::\n:::\n\n\nFunctions have **options** that can change their behaviour.\nSeparate options using a comma:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(x, digits = 1) # round to one decimal point\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 53.3\n```\n\n\n:::\n:::\n\n\n\n### Vector\n\nA **vector** is the most basic type of object in R. \nIt is a collection of values, which are _all of the same type_, for example numeric, character or logical (TRUE/FALSE).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx_chr <- c(\"dog\", \"cat\", \"goldfish\")   # character vector\nx_num <- c(1, 5, 23.3, 55.2)           # numeric vector\nx_log <- c(TRUE, TRUE, FALSE, TRUE)    # logical vector\n```\n:::\n\n\n**Access values** inside the vector with `[]`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx_chr[2]        # the second value\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"cat\"\n```\n\n\n:::\n\n```{.r .cell-code}\nx_chr[c(2, 3)]  # the second and third values\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"cat\"      \"goldfish\"\n```\n\n\n:::\n:::\n\n\n\n### Conditions\n\nIn many situations (for example to filter rows in a table), it's useful to evaluate a set of conditions. \nWe can create logical vectors using **conditions**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx_num\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1.0  5.0 23.3 55.2\n```\n\n\n:::\n\n```{.r .cell-code}\n# is x_num greater than 20?\nx_num > 20\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE  TRUE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n# is x_num equal to 5?\nx_num == 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n# is x_num contained the vector on the right?\nx_num %in% c(20, 30, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n\nCombine conditions with & (AND) and | (OR):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx_num\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1.0  5.0 23.3 55.2\n```\n\n\n:::\n\n```{.r .cell-code}\n# is x_num greater than or equal to 10 AND smaller than or equal to 30?\nx_num >= 10 & x_num <= 30\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE  TRUE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n# is x_num smaller than 10 OR greater than 30?\nx_num < 10 | x_num > 30\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE  TRUE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\nTo set the filtering conditions, several _relational operators_ can be used:\n\n* `==` is equal to\n* `!=` is different from\n* `%in%` is contained in\n* `>` is greater than\n* `>=` is greater than or equal to\n* `<` is less than\n* `<=` is less than or equal to\n\nIt is also possible to combine several conditions together using the following _logical operators_:\n\n* `&` AND\n* `|` OR\n\n\n### Missing Values\n\nSometimes we have **missing values** in our data, which are encoded as `NA`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- c(23, 44, NA, 212)\n```\n:::\n\n\nWe need to ensure these are dealt with properly\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# returns NA\nmean(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\n# removes NA and then calculates mean\nmean(y, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 93\n```\n\n\n:::\n:::\n\n\nThe `is.na()` function is important to deal with missing values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  23  44  NA 212\n```\n\n\n:::\n\n```{.r .cell-code}\n# create a logical that is true if value is missing\nis.na(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE  TRUE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n# Negate that expression using !\n!is.na(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE  TRUE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n\n### Tables: `data.frame`/`tibble`\n\nTables in R are called **data.frame**.\nThe `tidyverse` package has its own version of a data.frame called a `tibble`. \nFor the most part they are basically equivalent, but the `tibble` object has a nicer printing function to display our data on the console. \n\nAs an example for working with tables in R, let's read a TSV (tab-delimited) file that contains intervals of missing information in 5 SARS-CoV-2 consensus sequences (this data comes from the [Switzerland case study](../03-case_studies/01-switzerland.md)).\nTo import a TSV file into R as a data.frame we can use the function `read_tsv()` (for a CSV file we would use `read_csv()`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmissing_intervals <- read_tsv(\"missing_intervals.tsv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 132 Columns: 6\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (4): seqID, patternName, pattern, strand\ndbl (2): start, end\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\nWhen we read the table in, we get a message informing us of the column types found. \nIn this case we have character columns containing text (indicated by `chr`) and numeric columns (indicated by `dbl`, which refers to the [double-precission floating point format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format) that computers use to store numbers). \n\nTo see the content of the table you can type the name of the object: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmissing_intervals\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 132 × 6\n   seqID patternName pattern strand start   end\n   <chr> <chr>       <chr>   <chr>  <dbl> <dbl>\n 1 CH01  N+          N+      +          1    54\n 2 CH01  N+          N+      +       1193  1264\n 3 CH01  N+          N+      +       4143  4322\n 4 CH01  N+          N+      +       6248  6294\n 5 CH01  N+          N+      +       7561  7561\n 6 CH01  N+          N+      +       9243  9311\n 7 CH01  N+          N+      +      10367 10367\n 8 CH01  N+          N+      +      11361 11370\n 9 CH01  N+          N+      +      13599 13613\n10 CH01  N+          N+      +      16699 16758\n# ℹ 122 more rows\n```\n\n\n:::\n:::\n\n\nSometimes a more convenient way is to click the name of the table on the environment, which opens a new tab to preview your data. \n\n![Data viewer in RStudio.](images/rstudio_data_viewer.svg)\n\n\n## Data Manipulation\n\nMost of the work you will do in R is with tables of data (`data.frame`/`tibble` objects). \nThere are several ways to manipulate tables in R, but we will give a quick overview of the functionality available through the `tidyverse` collection of packages. \n\n### Basic \"verbs\"\n\nThere's a set of basic functions that can be thought of as \"data manipulation verbs\". \nThey are: \n\n- `mutate()` → add a new column of modify an existing one.\n- `select()` → select columns from the table.\n- `filter()` → subset the rows from the table that fullfill a certain logical condition.\n\nHere are some examples of each: \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a new column with the missing interval lengths\nmutate(missing_intervals, \n       length = (end - start) + 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 132 × 7\n   seqID patternName pattern strand start   end length\n   <chr> <chr>       <chr>   <chr>  <dbl> <dbl>  <dbl>\n 1 CH01  N+          N+      +          1    54     54\n 2 CH01  N+          N+      +       1193  1264     72\n 3 CH01  N+          N+      +       4143  4322    180\n 4 CH01  N+          N+      +       6248  6294     47\n 5 CH01  N+          N+      +       7561  7561      1\n 6 CH01  N+          N+      +       9243  9311     69\n 7 CH01  N+          N+      +      10367 10367      1\n 8 CH01  N+          N+      +      11361 11370     10\n 9 CH01  N+          N+      +      13599 13613     15\n10 CH01  N+          N+      +      16699 16758     60\n# ℹ 122 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n# select only a few columns of the table\nselect(missing_intervals,\n       seqID, start, end)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 132 × 3\n   seqID start   end\n   <chr> <dbl> <dbl>\n 1 CH01      1    54\n 2 CH01   1193  1264\n 3 CH01   4143  4322\n 4 CH01   6248  6294\n 5 CH01   7561  7561\n 6 CH01   9243  9311\n 7 CH01  10367 10367\n 8 CH01  11361 11370\n 9 CH01  13599 13613\n10 CH01  16699 16758\n# ℹ 122 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n# subset the table to include only intervals within the Spike protein\nfilter(missing_intervals,\n       start > 21563 & end < 25384)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 15 × 6\n   seqID patternName pattern strand start   end\n   <chr> <chr>       <chr>   <chr>  <dbl> <dbl>\n 1 CH01  N+          N+      +      21621 21670\n 2 CH01  N+          N+      +      23480 23507\n 3 CH02  N+          N+      +      21620 21670\n 4 CH02  N+          N+      +      23480 23508\n 5 CH03  N+          N+      +      21621 21670\n 6 CH03  N+          N+      +      23480 23507\n 7 CH04  N+          N+      +      21620 21670\n 8 CH04  N+          N+      +      22240 22240\n 9 CH04  N+          N+      +      23480 23509\n10 CH04  N+          N+      +      24062 24395\n11 CH05  N+          N+      +      21620 22530\n12 CH05  N+          N+      +      23489 24709\n13 CH06  N+          N+      +      21605 22515\n14 CH06  N+          N+      +      23474 23525\n15 CH06  N+          N+      +      23721 24694\n```\n\n\n:::\n:::\n\n\n\n### Pipes\n\nWe can chain multiple commands together using **pipes** (similarly to pipes in _Unix_). \nIn R the pipe is represented by `|>` (or `%>%`). \nThe way the pipe works is that the output of one function is sent as the input to the next function. \n\nTaking the examples from the previous section, we could chain all those commands like this: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmissing_intervals |> \n  mutate(length = (end - start) + 1) |> \n  select(seqID, start, end, length)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 132 × 4\n   seqID start   end length\n   <chr> <dbl> <dbl>  <dbl>\n 1 CH01      1    54     54\n 2 CH01   1193  1264     72\n 3 CH01   4143  4322    180\n 4 CH01   6248  6294     47\n 5 CH01   7561  7561      1\n 6 CH01   9243  9311     69\n 7 CH01  10367 10367      1\n 8 CH01  11361 11370     10\n 9 CH01  13599 13613     15\n10 CH01  16699 16758     60\n# ℹ 122 more rows\n```\n\n\n:::\n:::\n\n\nIf you want to _update_ the `missing_intervals` table, then you need to use `<-` at the beggining of the chain of pipes: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmissing_intervals <- missing_intervals |> \n  mutate(length = (end - start) + 1) |> \n  select(seqID, start, end, length)\n```\n:::\n\n\n### Grouped Summaries\n\nWe can calculate summaries of the data (e.g. mean, standard deviation, maximum, minimum) per group (e.g. per sample) using a pair of functions together. \nFor example: \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# mean and maximum interval length per sample\nmissing_intervals |> \n  # for each sample\n  group_by(seqID) |> \n  # calculate summary statistics\n  summarise(max_length = max(length),\n            min_length = min(length),\n            mean_length = mean(length))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 4\n  seqID max_length min_length mean_length\n  <chr>      <dbl>      <dbl>       <dbl>\n1 CH01         238          1        57  \n2 CH02         274          2        66  \n3 CH03         279         10        70.4\n4 CH04        1011          1       178. \n5 CH05        1221         11       200  \n6 CH06         974          1       166. \n7 CH07        5130          1       343. \n```\n\n\n:::\n:::\n\n\nAs before, if we wanted to save this result in a new object, we would need to use `<-`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nintervals_summary <- missing_intervals |> \n  # for each sample\n  group_by(seqID) |> \n  # calculate summary statistics\n  summarise(max_length = max(length),\n            min_length = min(length),\n            mean_length = mean(length)) |> \n  # and rename the seqID column\n  rename(sample = seqID)\n```\n:::\n\n\nNotice in this case we also renamed the column called `seqID` to be named `sample` instead (this will be useful for the exercise later on). \n\nAnother useful function is `count()`, which counts how many times the values in a column appear on a data frame. \nFor example, if we wanted to know how many missing intervals each sample had, we could do it like this: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmissing_intervals |> \n  count(seqID)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 2\n  seqID     n\n  <chr> <int>\n1 CH01     16\n2 CH02     19\n3 CH03     16\n4 CH04     21\n5 CH05     15\n6 CH06     16\n7 CH07     29\n```\n\n\n:::\n:::\n\n\n:::{.callout-exercise}\n\nModify the following code: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmissing_intervals |> \n  count(seqID)\n```\n:::\n\n\nTo also: \n\n- rename the column `seqID` to be named `sample` instead. \n- save the output in an object called `intervals_count`. \n\n:::{.callout-answer}\nTo rename the column, we could use the `rename()` function: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmissing_intervals |> \n  count(seqID) |> \n  rename(sample = seqID)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 2\n  sample     n\n  <chr>  <int>\n1 CH01      16\n2 CH02      19\n3 CH03      16\n4 CH04      21\n5 CH05      15\n6 CH06      16\n7 CH07      29\n```\n\n\n:::\n:::\n\n\nAnd to save this output to a new object, we need to use `<-`: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nintervals_count <- missing_intervals |> \n  count(seqID) |> \n  rename(sample = seqID)\n```\n:::\n\n\n:::\n:::\n\n### Joining Tables\n\nWe can join multiple tables together based on a common identifier. \nThere are different types of join operations, depending on what we want to achieve. \n\nTake these two tables as an example (these tables come pre-loaded with `tidyverse`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nband_members\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  name  band   \n  <chr> <chr>  \n1 Mick  Stones \n2 John  Beatles\n3 Paul  Beatles\n```\n\n\n:::\n\n```{.r .cell-code}\nband_instruments\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  name  plays \n  <chr> <chr> \n1 John  guitar\n2 Paul  bass  \n3 Keith guitar\n```\n\n\n:::\n:::\n\n\nHere are some different ways we can join these tables:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# keep all records from both tables\nfull_join(band_members, band_instruments, by = \"name\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 3\n  name  band    plays \n  <chr> <chr>   <chr> \n1 Mick  Stones  <NA>  \n2 John  Beatles guitar\n3 Paul  Beatles bass  \n4 Keith <NA>    guitar\n```\n\n\n:::\n\n```{.r .cell-code}\n# keep all records from the first table\nleft_join(band_members, band_instruments, by = \"name\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  name  band    plays \n  <chr> <chr>   <chr> \n1 Mick  Stones  <NA>  \n2 John  Beatles guitar\n3 Paul  Beatles bass  \n```\n\n\n:::\n\n```{.r .cell-code}\n# keep all records from the second table\nright_join(band_members, band_instruments, by = \"name\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  name  band    plays \n  <chr> <chr>   <chr> \n1 John  Beatles guitar\n2 Paul  Beatles bass  \n3 Keith <NA>    guitar\n```\n\n\n:::\n\n```{.r .cell-code}\n# keep only the records occurring in both tables\ninner_join(band_members, band_instruments, by = \"name\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 3\n  name  band    plays \n  <chr> <chr>   <chr> \n1 John  Beatles guitar\n2 Paul  Beatles bass  \n```\n\n\n:::\n:::\n\n\nIn each case, if there was no match between the two tables, the cells are filled with missing values `NA`. \n\n:::{.callout-exercise}\n\nIn this exercise we will join the `intervals_summary` table we created earlier, with the metadata table that contains information about our samples. \n\n1. Read the your metadata table `sample_info.csv` into R and save it as an object called `sample_info`. \n  <details><summary>Hint</summary>Remember that you can use the `read_csv()` function to read CSV files into R.</details>\n2. Join the `sample_info` table that you just imported with the `intervals_summary` table we created earlier. \n  Save the output to the `intervals_summary` table (this will update the table). \n  <details><summary>You can use the `left_join()` function to achieve this, using the \"sample\" column as the identifier column used to join the two tables.</summary></details>\n\n:::{.callout-answer}\n\n**Answer 1**\n\nTo read the metadata CSV file, we use the `read_csv()` function, and use `<-` to save the output in an object called `sample_info`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample_info <- read_csv(\"sample_info.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 7 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (3): sample, country, sequencing_instrument\ndate (1): collection_date\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\nWe can see the content of our file by typing its name in the console.\nHere is the file in our example data (yours might look different):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample_info\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 4\n  sample collection_date country     sequencing_instrument\n  <chr>  <date>          <chr>       <chr>                \n1 CH01   2021-11-09      Switzerland GridION              \n2 CH04   2021-12-20      Switzerland GridION              \n3 CH05   2021-12-20      Switzerland GridION              \n4 CH06   2021-12-20      Switzerland GridION              \n5 CH07   2021-12-20      Switzerland GridION              \n6 CH02   2021-12-21      Switzerland GridION              \n7 CH03   2021-12-22      Switzerland GridION              \n```\n\n\n:::\n:::\n\n\n**Answer 2**\n\nTo join the two tables together, we can use one of the `*_join()` functions. \nIn this case it doesn't matter which function we use, because both tables have the same sample IDs. \nBut, for example, let's say we only wanted to retain the samples that are in common across _both_ tables. \nIn that case, we would use `inner_join()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nintervals_summary <- inner_join(intervals_summary, sample_info, by = \"sample\")\n```\n:::\n\n\n:::\n:::\n\n\n## Data Visualisation\n\nFor this section, we will use another table, which contains some of the metrics that we can collect from our consensus pipeline: \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# read the table\nqc_metrics <- read_tsv(\"consensus_metrics.tsv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 7 Columns: 6\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (3): sample, qc_status, lineage\ndbl (3): n_mapped_reads, median_depth, pct_missing\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\n# preview the table\nqc_metrics\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 6\n  sample n_mapped_reads median_depth pct_missing qc_status lineage\n  <chr>           <dbl>        <dbl>       <dbl> <chr>     <chr>  \n1 CH01            43900          248        3.05 good      BA.1   \n2 CH02            42841          159        4.20 good      BA.1   \n3 CH03            40079          160        3.77 good      BA.1   \n4 CH04            50902          164       12.5  bad       BA.1   \n5 CH05            32020          133       10.0  bad       BA.1   \n6 CH06            46277          177        8.87 mediocre  BA.1.1 \n7 CH07            15867           41       33.2  bad       None   \n```\n\n\n:::\n:::\n\n\nWe can build plots from our tables using the `ggplot2` package (which is also part of the `tidyverse`). \n\nTo build a _ggplot_, we usually need at least three things:  \n\n- The data frame we want to use for the plot (the **data**).\n- The columns we want to visualise as our x-axis, y-axis, and colours (these are called **aesthetics**).\n- The type of shape that we want to plot (these are called **geometries**).\n\nFor example, let's try to make a plot to show the relationship between total number of counts and the median depth of sequencing in these samples:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = qc_metrics, aes(x = n_mapped_reads, y = median_depth))\n```\n\n::: {.cell-output-display}\n![](quick_r_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n\nWhen we do this, we simply get an empty plot, with x and y axis, but nothing drawn on it. \nTo draw something on the plot, we add (literally with `+`) geometries to our plot. \nIn this case, we can use the `geom_point()` geometry, which draws \"points\" on the plot:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = qc_metrics, aes(x = n_mapped_reads, y = median_depth)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](quick_r_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n:::\n\n\nThere are many geometries available with ggplot: \n\n- `geom_point()` draws points. \n- `geom_boxplot()` draws a boxplot. \n- `geom_histogram()` draws a histogram. \n- `geom_col()` draws a barplot (this one is named a little strangely, but \"col\" means it draws \"columns\" or bars).\n\nWe can further modify the look to the plot by adding other _aesthetics_ such as the colour of the points. \nFor example, let's say we wanted to colour our points according to their \"QC Status\":\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = qc_metrics, \n       aes(x = n_mapped_reads, y = median_depth, colour = qc_status)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](quick_r_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n:::\n\n\nFinally, we may sometimes want to change the _labels_ of our plot. \nIn that case, we can add the `labs()` function to our plotting code: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = qc_metrics, \n       aes(x = n_mapped_reads, y = median_depth, colour = qc_status)) +\n  geom_point() +\n  labs(x = \"Number Mapped Reads\", \n       y = \"Median Sequencing Depth\", \n       colour = \"Nextclade QC Status\")\n```\n\n::: {.cell-output-display}\n![](quick_r_files/figure-html/unnamed-chunk-35-1.png){width=672}\n:::\n:::\n\n\n:::{.callout-exercise}\n\nModify the plot we just did, to show the relationship between median depth of sequencing (x-axis) and percentage of missing bases (y-axis). \nColour the points according to the lineage column. \n\n:::{.callout-answer}\n\nHere is the modified code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = qc_metrics, \n       aes(x = median_depth, y = pct_missing, colour = lineage)) +\n  geom_point() +\n  labs(x = \"Median Sequencing Depth\", \n       y = \"% Missing Bases\", \n       colour = \"Pango Lineage\")\n```\n\n::: {.cell-output-display}\n![](quick_r_files/figure-html/unnamed-chunk-36-1.png){width=672}\n:::\n:::\n\n\nThe things we have changed were the aesthetics and labels. \n\n:::\n:::\n",
    "supporting": [
      "quick_r_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}