---
pagetitle: "SARS-CoV-2 Genomics"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# R Fundamentals

This section gives a (very) quick and brief introduction to R and RStudio. 
It will not teach you the details of how to program in R, but it should serve as a basis to start you on that journey. 
R can be used for a range of data analysis applications, including statistics, machine learning, plotting, image analysis, bioinformatics, etc. 
R is also a programming language, which makes it very flexible. 
With this flexibility, comes a somewhat steeper learning curve, compared to point-and-click programs. 
However, in the long run it can really help you improve as a data analyst. 

These materials will not teach you the details of how to write your own R programs (we won't have time for these), but to make you familiar with some of its applications and how to use RStudio to run your code.
It's only the start of your journey into R programming. 

If you want to learn more about this topic, we recommend:

- [R for Data Science](https://r4ds.had.co.nz/) - available as a free e-book.
- [Introduction to R/tidyverse](https://tavareshugo.github.io/r-intro-tidyverse-gapminder/) - course materials introducing R and the `tidyverse` packages. 


## RStudio

R is the software and programming language itself, but the R interface is quite basic and not very user-friendly. 
Fortunately, there is a companion piece of software called _RStudio_, which makes working with R a little bit easier. 

There are 4 basic panels in RStudio (see image below):

- The “script” panel is essentially a text editor, where we can write code and save it as a text file, which in this case, because it contains R code, we call it an R script (but remember, a script is just a text file with some code in it. We’ve been creating shell scripts that run on the command line, here we have some R scripts, which contain R code)
- The “console” panel is where the code actually runs, or is executed. This is equivalent to the terminal, on the command line. If we want to execute a line of code, then we need to run it on the console. 
  - One nice feature of RStudio is that we can edit our code on the script panel and then run a line of code from the script on the console - it's like copy/pasting that line of code from the script to the console. This makes working interactively with RStudio much easier, because we can edit our code in the script and run it as we go along. 
- On the top-right we have the “Environment”, which shows us objects that we create, that store information such as tables of data that we read into R. 
- Finally we have the bottom-right quadrant, which contains a few tabs: a file browser (allowing us to see files in our computer), a plot display panel (for plots we generate) and a help panel to look at documentation of R functions.

![](images/rstudio_panels.png)


### Setting RStudio

Before we start working with RStudio, it’s a good idea to change one of its default options. 
Go to <kbd>Tools</kbd> → <kbd>Global Options...</kbd> and change the following:

![](images/rstudio_setup.png)

This will tell RStudio to NOT automatically save and load things that we have done in the past. 
You may think this is a helpful thing, but actually it’s very inconvenient, because if you are doing multiple analysis, it might get very very confusing what the objects that you created are! 
So, it’s always best to start R with a fresh session, and setting these options makes sure we do this. 


### Starting a Project

R has a concept called **working directory**, which is the location on your computer where it is working from (looking for files and folders). 
You can think of it as the folder that you `cd` into if you were working on the command-line. 

The easiest way to ensure that R is using the correct working directory for our analysis, is to create an **R project**. 
In RStudio: <kbd>File</kbd> → <kbd>New Project...</kbd> → <kbd>Existing Directory</kbd> and then click the <kbd>Browse...</kbd> button to navigate to the folder where your project files are located. 

This will create an `.Rproj` file on your project folder. 
Next time you want to work on your analysis, you can simply double-click on this file, and it will open RStudio, with the correct working directory already set for you. 


## R Basics

This section introduces some of the basic concepts in the R programming language. 

### Packages/Libraries

R has several extensions to the basic functionality called “packages” or “libraries”. 
A popular library for data manipulation is called `tidyverse`, which we are using in this course. 
Each time we start a new R session, we need to load the libraries we want to use: 

```{r, eval=FALSE}
library(tidyverse)
```

```{r, echo=FALSE, warning=FALSE, message=FALSE}
# this reduces dependencies for github actions
library(dplyr)
library(readr)
```

If you get an error like `Error in library(tidyverse) : there is no package called ‘tidyverse’`, that means that you didn't install the package. 
To install packages you can run: 

```{r, eval=FALSE}
install.packages("tidyverse")
```

You only need to do this the first time you want to use a library. 
Once it's installed, you don't need to run this command again (unless you want to update the library to its latest version -- often a good idea!).


### Create objects

Create **objects** (something that contains a value) with `<-`.
For example, the following creates an object called `x` containing a single number:

```{r}
x <- 53.341
```

We can print the content of the object by typing its name:

```{r}
x
```


### Functions

Most of the tasks we can achieve in R are done through the use of **functions**. 
We can think of functions as mini-programs that take an input and give an output.

Functions are easy to identify, because they are always followed by parenthesis. 
Inside the parenthesis we include the _inputs_ to the function. 

```{r}
round(x)   # round the the value of x
```

Functions have **options** that can change their behaviour.
Separate options using a comma:

```{r}
round(x, digits = 1) # round to one decimal point
```


### Vector

A **vector** is the most basic type of object in R. 
It is a collection of values, which are _all of the same type_, for example numeric, character or logical (TRUE/FALSE).

```{r}
x_chr <- c("dog", "cat", "goldfish")   # character vector
x_num <- c(1, 5, 23.3, 55.2)           # numeric vector
x_log <- c(TRUE, TRUE, FALSE, TRUE)    # logical vector
```

**Access values** inside the vector with `[]`:

```{r}
x_chr[2]        # the second value
x_chr[c(2, 3)]  # the second and third values
```


### Conditions

In many situations (for example to filter rows in a table), it's useful to evaluate a set of conditions. 
We can create logical vectors using **conditions**:

```{r}
x_num

# is x_num greater than 20?
x_num > 20

# is x_num equal to 5?
x_num == 5

# is x_num contained the vector on the right?
x_num %in% c(20, 30, 1)
```

Combine conditions with & (AND) and | (OR):

```{r}
x_num

# is x_num greater than or equal to 10 AND smaller than or equal to 30?
x_num >= 10 & x_num <= 30

# is x_num smaller than 10 OR greater than 30?
x_num < 10 | x_num > 30
```

To set the filtering conditions, several _relational operators_ can be used:

* `==` is equal to
* `!=` is different from
* `%in%` is contained in
* `>` is greater than
* `>=` is greater than or equal to
* `<` is less than
* `<=` is less than or equal to

It is also possible to combine several conditions together using the following _logical operators_:

* `&` AND
* `|` OR


### Missing Values

Sometimes we have **missing values** in our data, which are encoded as `NA`:

```{r}
y <- c(23, 44, NA, 212)
```

We need to ensure these are dealt with properly

```{r}
# returns NA
mean(y)

# removes NA and then calculates mean
mean(y, na.rm = TRUE)
```

The `is.na()` function is important to deal with missing values:

```{r}
y

# create a logical that is true if value is missing
is.na(y)

# Negate that expression using !
!is.na(y)
```


### Tables: `data.frame`/`tibble`

A **data.frame** is a tabular object (rows and columns).
The `tidyverse` package has its own version of a data.frame called a `tibble`. 
For the most part they are basically equivalent, but the `tibble` object has a nicer printing function to display our data on the console. 

Usually we create these objects by reading a table from a file with the function `read_csv()`:

```{r, eval=FALSE}
animals <- read_csv("TODO")
```


```{r, echo=FALSE}
animals <- tibble(
  common_name = c("mouse", "mouse", "dog", "cat", "dog"),
  scientific_name = c("Mus musculus", "Mus musculus", "Canis familiaris", "Felis catus", "Canis familiaris"),
  weight_g = c(18.5, 21.1, 21812, 4221, 25193)
)
```

In this case we're reading some data from a web address (it just contains some measurements of animals collected in the wild). 
However, you would usually read data from a local file using regular **file paths**. 

To see the content of the table you can type the name of the object: 

```{r}
animals
```

Sometimes a more convenient way is to click the name of the table on the environment, which opens a new tab to preview your data. 

![TODO]()


## Data Manipulation

Most of the work you will do in R is with tables of data (data.frame`/`tibble` objects). 
There are several ways to manipulate tables in R, but we will give a quick overview of the functionality available through the `tidyverse` collection of packages. 

### Basic "verbs"

There's a set of basic functions that can be thought of as "data manipulation verbs". 
They are: 

- `mutate()` → add a new column of modify an existing one.
- `select()` → select columns from the table.
- `filter()` → subset the rows from the table that fullfill a certain logical condition.

Here are some examples of each: 

```{r}
# create a new column for weight in Kg
mutate(animals, 
       weight_kg = weight_g/1000)

# select only a few columns of the table
select(animals,
       common_name, weight_g)

# subset the table to include only animals with less than 1Kg
filter(animals,
       weight_g < 1000)
```


### Pipes

We can chain multiple commands together using **pipes** (similarly to pipes in _Unix_). 
In R the pipe is represented by `|>` (or `%>%`). 
The way the pipe works is that the output of one function is sent as the input to the next function. 

Taking the examples from the previous section, we could chain all those commands like this: 

```{r}
animals |> 
  mutate(weight_kg = weight_g/1000) |> 
  select(common_name, weight_kg) |> 
  filter(weight_kg < 1)
```


### Grouped Summaries

We can calculate summaries of the data (e.g. mean, standard deviation, maximum, minimum) per group (e.g. per country) using a pair of functions together. 
For example: 

```{r}
# mean and maximum weight per animal
animals |> 
  group_by(common_name) |> 
  summarise(max_weight = max(weight_g),
            mean_weight = mean(weight_g))
```


### Joining Tables

We can join multiple tables together based on a common identifier. 
There are different types of join operations, depending on what we want to achieve. 

Take these two tables as an example (these tables come pre-loaded with `tidyverse`):

```{r}
band_members
band_instruments
```

Here are some different ways we can join these tables:

```{r}
# keep all records from both tables
full_join(band_members, band_instruments, by = "name")

# keep all records from the first table
left_join(band_members, band_instruments, by = "name")

# keep all records from the second table
right_join(band_members, band_instruments, by = "name")

# keep only the records occurring in both tables
inner_join(band_members, band_instruments, by = "name")
```

In each case, if there was no match between the two tables, the cells are filled with missing values `NA`. 
